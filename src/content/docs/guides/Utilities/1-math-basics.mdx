---
title: Basic Maths Operations
description: Learn how to perform basic mathematical operations in programming, including square roots, prime numbers, factors, greatest common divisors, least common multiples, and modular arithmetic.
category: Guides
author: Brianna Laird
lastupdated: November 2024
---

import { Tabs, TabItem } from "@astrojs/starlight/components";

**{frontmatter.description}**  
Written by: {frontmatter.author}  
_Last updated: {frontmatter.lastupdated}_

---

Mathematics is a fundamental part of programming, providing essential tools and methods that enable developers to solve complex problems efficiently. This guide explores a range of mathematical operations and demonstrates how to implement them effectively. In later tutorials, you'll learn how to integrate these operations into your SplashKit projects to create programs, games and encrypted messaging applications.

## Basic Maths Operations

This section introduces fundamental mathematical operations that are essential for programming. We'll explore various mathematical functions and algorithms, starting with basic calculations like square roots and progressing to more complex operations like finding prime numbers and calculating greatest common divisors, least common multiples, and finding factors.

### Square Root

The square root of a number is a value that, when multiplied by itself, gives the original number. For example, the square root of $9$ is $3$ since $3 × 3 = 9$.

To calculate the square root efficiently, we use the Newton-Raphson method, an iterative numerical technique for finding roots of real-valued functions. This method starts with an initial estimate and repeatedly refines it using the formula:

$$
x_{n+1} = \frac{1}{2}(x_n + \frac{N}{x_n})
$$

Where:

- $x_n$ is the current estimate
- $N$ is the number we want to find the square root of
- $x_{n+1}$ is the improved estimate

This can be implemented in code as follows:

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
double calculate_square_root(int n)
{
    if (n == 0 || n == 1)
        return n;

    double estimate = n;
    double precision = 0.00001; // The precision of the estimate

    // The Newton-Raphson method
    while ((estimate - n / estimate) > precision)
    {
        estimate = (estimate + n / estimate) / 2.0;
    }

    return estimate;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
double CalculateSquareRoot(int n)
{
    if (n == 0 || n == 1)
        return n;

    double estimate = n;
    double precision = 0.00001; // The precision of the estimate

    // The Newton-Raphson method
    while ((estimate - n / estimate) > precision)
    {
        estimate = (estimate + n / estimate) / 2.0;
    }

    return estimate;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
double CalculateSquareRoot(int n)
{
    if (n == 0 || n == 1)
        return n;

    double estimate = n;
    double precision = 0.00001; // The precision of the estimate

    // The Newton-Raphson method
    while ((estimate - n / estimate) > precision)
    {
        estimate = (estimate + n / estimate) / 2.0;
    }

    return estimate;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def calculate_square_root(n):
    if n == 0 or n == 1:
        return n

    estimate = n
    precision = 0.00001 # The precision of the estimate

    # The Newton-Raphson method
    while (estimate - n / estimate) > precision:
        estimate = (estimate + n / estimate) / 2.0

    return estimate
```

</TabItem>
</Tabs>

### Prime Number

A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. To check if a number is prime, you will need to also calculate the square root of the number. You can use the following functions to check if a number is prime:

To check if a number is prime, we can use a simple algorithm that checks if the number is divisible by any number from 2 to its square root. The logic behind this approach is based on the following mathematical principles:

1. Any non-prime number $n$ can be written as a product of two factors: $n = a \times b$
2. If $n$ is not prime, at least one of these factors must be less than or equal to $\sqrt{n}$
3. If we can't find any factors up to $\sqrt{n}$, then the number must be prime

This can be implemented in code as follows:

:::note
This function relies on the `calculate_square_root` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
bool is_the_number_prime(int n)
{
    if (n <= 1) return false;

    // Check if the number is divisible by any number from 2 to the square root of the number
    for (int i = 2; i <= calculate_square_root(n); i++)
    {
        if (n % i == 0)
            return false;
    }
    return true;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
bool IsTheNumberPrime(int n)
{
    if (n <= 1) return false;

    // Check if the number is divisible by any number from 2 to the square root of the number
    for (int i = 2; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
            return false;
    }
    return true;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
bool IsTheNumberPrime(int n)
{
    if (n <= 1) return false;

    // Check if the number is divisible by any number from 2 to the square root of the number
    for (int i = 2; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
            return false;
    }
    return true;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def is_the_number_prime(n):
    if n <= 1:
        return False

    # Check if the number is divisible by any number from 2 to the square root of the number
    for i in range(2, int(calculate_square_root(n)) + 1):
        if n % i == 0:
            return False
    return True
```

</TabItem>
</Tabs>

### Finding Prime Numbers up to a Given Number

Finding prime numbers up to a given number is a common task in number theory and cryptography. The following function implements the Sieve of Eratosthenes algorithm, which efficiently finds all prime numbers up to a specified maximum $n$. The algorithm works by:

1. Creating a list of numbers from 2 to $n$
2. Starting with $p=2$ (the first prime), marking all multiples of $p$ up to $n$ as composite
3. Finding the next unmarked number and repeating step 2
4. The remaining unmarked numbers are prime

This can be expressed mathematically as finding all numbers $p$ where:

$$
p \in \{2,\ldots,n\} \text{ and } p \nmid k \text{ for all } k < p
$$

For example, to find primes up to 20, we would mark off:

- Multiples of 2: $4, 6, 8, 10, 12, 14, 16, 18, 20$
- Multiples of 3: $9, 15$
- Multiples of 5: none remaining
- Leaving primes: $2, 3, 5, 7, 11, 13, 17, 19$

:::note
This function relies on the `is_the_number_prime` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
void find_prime_numbers_up_to(int limit)
{
    write_line("Prime numbers up to " + std::to_string(limit) + ":");

    // Check all numbers up to the limit to see if they are prime
    for (int i = 2; i <= limit; i++)
    {
        if (is_the_number_prime(i))
        {
            write(std::to_string(i) + " ");
        }
    }
    write_line("");
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
void FindPrimeNumbersUpTo(int limit)
{
    WriteLine($"Prime numbers up to {limit}:");

    // Check all numbers up to the limit to see if they are prime
    for (int i = 2; i <= limit; i++)
    {
        if (IsTheNumberPrime(i))
        {
            Write($"{i} ");
        }
    }
    WriteLine("");
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
void FindPrimeNumbersUpTo(int limit)
{
    SplashKit.WriteLine($"Prime numbers up to {limit}:");

    // Check all numbers up to the limit to see if they are prime
    for (int i = 2; i <= limit; i++)
    {
        if (IsTheNumberPrime(i))
        {
            SplashKit.Write($"{i} ");
        }
    }
    SplashKit.WriteLine("");
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def find_prime_numbers_up_to(limit):
    write_line(f"Prime numbers up to {limit}:")

    # Check all numbers up to the limit to see if they are prime
    for i in range(2, limit + 1):
        if is_the_number_prime(i):
            write(f"{i} ")
    write_line("")
```

</TabItem>
</Tabs>

### Finding the Number of Divisors

The number of divisors of a positive integer $n$ is the count of positive integers that divide $n$ without leaving a remainder. We can find the number of divisors efficiently by only checking up to $\sqrt{n}$ because divisors come in pairs.

For any divisor $d$ of $n$, there exists a corresponding divisor $\frac{n}{d}$ such that $d \times \frac{n}{d} = n$. For example, for $n=12$:

- When $d=1$, we get $\frac{n}{d}=12$
- When $d=2$, we get $\frac{n}{d}=6$
- When $d=3$, we get $\frac{n}{d}=4$

Therefore, except for perfect squares where $d=\sqrt{n}$, divisors occur in pairs. The total count can be calculated by:

$$
\text{divisors}(n) = 2 \times |\{d : d|\sqrt{n}\}| + |\{d : d^2=n\}|
$$

where $d|n$ denotes that $d$ divides $n$ evenly.

:::note
This function relies on the `calculate_square_root` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int count_divisors(int n)
{
    int count = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= calculate_square_root(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, count only one
            if (n / i == i)
                count++;
            // Otherwise count both
            else
                count += 2;
        }
    }
    return count;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int CountDivisors(int n)
{
    int count = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, count only one
            if (n / i == i)
                count++;
            // Otherwise count both
            else
                count += 2;
        }
    }
    return count;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int CountDivisors(int n)
{
    int count = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, count only one
            if (n / i == i)
                count++;
            // Otherwise count both
            else
                count += 2;
        }
    }
    return count;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def count_divisors(n):
    count = 0

    # Check all numbers up to the square root of n
    for i in range(1, int(calculate_square_root(n)) + 1):
        if n % i == 0:
            # If divisors are equal, count only one
            if n // i == i:
                count += 1
            # Otherwise count both
            else:
                count += 2
    return count
```

</TabItem>
</Tabs>

### Finding the Sum of Divisors

The sum of divisors of a positive integer is the sum of all positive integers that divide the number without leaving a remainder. This function calculates the sum of divisors of a given number by iterating through all numbers up to the square root of the input number and summing the divisors.

For a number $n$, finding the sum of its divisors involves:

1. Iterating through numbers from 1 to $\sqrt{n}$
2. For each divisor $d$, if $n$ is divisible by $d$:
    - If $d^2 = n$, add $d$ once
    - Otherwise, add both $d$ and $\frac{n}{d}$

For example, for $n=12$:

- Divisors are: 1, 2, 3, 4, 6, 12
- Sum = 1 + 2 + 3 + 4 + 6 + 12 = 28

This can be expressed mathematically as:

$$
\sum_{d|n} d = \sum_{d \leq \sqrt{n}} d \cdot [n \bmod d = 0] + \frac{n}{d} \cdot [d^2 \neq n]
$$

where $[P]$ is 1 if condition $P$ is true, and 0 otherwise.


:::note
This function relies on the `calculate_square_root` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int sum_divisors(int n)
{
    int sum = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= calculate_square_root(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, add only one
            if (n / i == i)
                sum += i;
            // Otherwise add both
            else
                sum += i + n / i;
        }
    }
    return sum;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int SumDivisors(int n)
{
    int sum = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, add only one
            if (n / i == i)
                sum += i;
            // Otherwise add both
            else
                sum += i + n / i;
        }
    }
    return sum;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int SumDivisors(int n)
{
    int sum = 0;

    // Check all numbers up to the square root of n
    for (int i = 1; i <= CalculateSquareRoot(n); i++)
    {
        if (n % i == 0)
        {
            // If divisors are equal, add only one
            if (n / i == i)
                sum += i;
            // Otherwise add both
            else
                sum += i + n / i;
        }
    }
    return sum;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def sum_divisors(n):
    sum = 0

    # Check all numbers up to the square root of n
    for i in range(1, int(calculate_square_root(n)) + 1):
        if n % i == 0:
            # If divisors are equal, add only one
            if n // i == i:
                sum += i
            # Otherwise add both
            else:
                sum += i + n // i
    return sum
```

</TabItem>
</Tabs>

### Greatest Common Divisor

The greatest common divisor (GCD) of two numbers is the largest positive integer that divides both numbers without leaving a remainder. The algorithm works by repeatedly dividing the larger number by the smaller number and replacing the larger number with the remainder until the remainder is zero. The last non-zero remainder is the GCD of the two numbers. This algorithm is known as the Euclidean algorithm which can be expressed mathematically as:

$$
\text{GCD}(a,b) = \text{GCD}~(b, a \bmod b)
$$

where $a \bmod b$ represents the remainder when $a$ is divided by $b$.

You can use the following functions to calculate the GCD of two numbers:

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int greatest_common_divisor(int a, int b)
{

    // Repeat the euclidean algorithm until the remainder is zero
    while (b != 0)
    {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int GreatestCommonDivisor(int a, int b)
{

    // Repeat the euclidean algorithm until the remainder is zero
    while (b != 0)
    {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int GreatestCommonDivisor(int a, int b)
{

    // Repeat the euclidean algorithm until the remainder is zero
    while (b != 0)
    {
        int temp = b;
        b = a % b;
        a = temp;
    }
    return a;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def greatest_common_divisor(a, b):

    # Repeat the euclidean algorithm until the remainder is zero
    while b != 0:
        temp = b
        b = a % b
        a = temp
    return a
```

</TabItem>
</Tabs>

### Least Common Multiple

The least common multiple (LCM) of two numbers is the smallest positive integer that is divisible by both of those numbers. An efficient way to calculate the LCM is by using the relationship between the LCM and the greatest common divisor (GCD) of those numbers. The formula for finding the LCM using the GCD is:

$$
\text{LCM}(a, b) = \frac{|a \times b|}{\text{GCD}(a, b)}
$$

:::note
This function relies on the `greatest_common_divisor` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int least_common_multiple(int a, int b)
{
    return abs(a * b) / greatest_common_divisor(a, b);
}

```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int LeastCommonMultiple(int a, int b)
{
    return Math.Abs(a * b) / GreatestCommonDivisor(a, b);
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int LeastCommonMultiple(int a, int b)
{
    return Math.Abs(a * b) / GreatestCommonDivisor(a, b);
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def least_common_multiple(a, b):
    return abs(a * b) // greatest_common_divisor(a, b)
```

</TabItem>
</Tabs>

### Checking for Coprime Numbers

Two numbers are coprime (or relatively prime) if their greatest common divisor (GCD) is 1. For example, 8 and 15 are coprime because their GCD is 1, even though neither number is prime.

:::note
This function relies on the `greatest_common_divisor` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
bool are_coprime(int a, int b) 
{
    return greatest_common_divisor(a, b) == 1;
}
```

</TabItem>
<TabItem label="C#">

```csharp
bool AreCoprime(int a, int b) 
{
    return GreatestCommonDivisor(a, b) == 1;
}
```

</TabItem>
<TabItem label="Python">

```python
def are_coprime(a, b):
    return greatest_common_divisor(a, b) == 1
```

</TabItem>
</Tabs>

### Finding All Coprime Numbers

Finding all numbers that are coprime to a given value is useful in many mathematical applications, particularly in cryptography and number theory. The following function identifies all numbers that are coprime to an input value up to a specified maximum. Two numbers are coprime if their greatest common divisor (GCD) is 1.

For example, if we want to find all numbers coprime to 12 up to 20, we would get: 1, 5, 7, 11, 13, 17, 19

:::note
This function relies on the `are_coprime` function defined above.
:::

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
void find_coprimes_up_to(int n, int max) 
{
    write_line("Numbers coprime to " + std::to_string(n) + " up to " + std::to_string(max) + ":");

    // Check all numbers up to the maximum
    for (int i = 1; i <= max; i++) 
    {
        if (are_coprime(n, i)) 
        {
            write(std::to_string(i) + " ");
        }
    }
    write_line("");
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
void FindCoprimesUpTo(int n, int max) 
{
    WriteLine($"Numbers coprime to {n} up to {max}:");

    // Check all numbers up to the maximum
    for (int i = 1; i <= max; i++) 
    {
        if (AreCoprime(n, i)) 
        {
            Write($"{i} ");
        }
    }
    WriteLine("");
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
void FindCoprimesUpTo(int n, int max) 
{
    SplashKit.WriteLine($"Numbers coprime to {n} up to {max}:");

    // Check all numbers up to the maximum
    for (int i = 1; i <= max; i++) 
    {
        if (AreCoprime(n, i)) 
        {
            SplashKit.Write($"{i} ");
        }
    }
    SplashKit.WriteLine("");
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def find_coprimes_up_to(n, max):
    write_line(f"Numbers coprime to {n} up to {max}:")

    # Check all numbers up to the maximum
    for i in range(1, max + 1):
        if are_coprime(n, i):
            write(f"{i} ")
    write_line("")
```

</TabItem>
</Tabs>

### Finding Factors

A factor is a number that divides evenly into another number with no remainder. For example, the factors of 12 are 1, 2, 3, 4, 6, and 12. Finding factors is useful in various mathematical applications, including:

- Simplifying fractions
- Finding common divisors
- Breaking down numbers into their prime factorisation

The following function finds all factors of a given number by checking all potential divisors up to the input number:

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
void find_factors(int n) 
{
    write_line("Factors of " + std::to_string(n) + ":");

    // Check all potential divisors up to n
    for (int i = 1; i <= n; i++) 
    {
        if (n % i == 0) 
        {
            write(std::to_string(i) + " ");
        }
    }
    write_line("");
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
void FindFactors(int n) 
{
    WriteLine($"Factors of {n}:");

    // Check all potential divisors up to n
    for (int i = 1; i <= n; i++) 
    {
        if (n % i == 0) 
        {
            Write($"{i} ");
        }
    }
    WriteLine("");
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
void FindFactors(int n) 
{
    SplashKit.WriteLine($"Factors of {n}:");

    // Check all potential divisors up to n
    for (int i = 1; i <= n; i++) 
    {
        if (n % i == 0) 
        {
            SplashKit.Write($"{i} ");
        }
    }
    SplashKit.WriteLine("");
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def find_factors(n):
    write_line(f"Factors of {n}:")

    # Check all potential divisors up to n
    factors = [i for i in range(1, n + 1) if n % i == 0]
    write(" ".join(map(str, factors)))
    write_line("")
```

</TabItem>
</Tabs>

### Finding Prime Factors

The prime factorisation of a number is its decomposition into a product of prime numbers. For example, 24 can be written as 2 × 2 × 2 × 3. The following function identifies all prime factors of a given number by:

1. First extracting all factors of 2 (the smallest prime number)
2. Then checking odd numbers up to the square root for remaining factors
3. If any number remains after this process, it must be a prime factor itself

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
void find_prime_factors(int n) 
{
    write_line("Prime factors of " + std::to_string(n) + ":");
    
    // Extract all factors of 2
    while (n % 2 == 0) 
    {
        write("2 ");
        n /= 2;
    }
    
    // Check odd numbers up to square root
    for (int i = 3; i * i <= n; i += 2) 
    {
        while (n % i == 0) 
        {
            write(std::to_string(i) + " ");
            n /= i;
        }
    }
    
    // If n is still greater than 2, it's a prime factor
    if (n > 2)
        write(std::to_string(n));
        
    write_line("");
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
void FindPrimeFactors(int n) 
{
    WriteLine($"Prime factors of {n}:");
    
    // Extract all factors of 2
    while (n % 2 == 0) 
    {
        Write("2 ");
        n /= 2;
    }
    
    // Check odd numbers up to square root
    for (int i = 3; i * i <= n; i += 2) 
    {
        while (n % i == 0) 
        {
            Write($"{i} ");
            n /= i;
        }
    }
    
    // If n is still greater than 2, it's a prime factor
    if (n > 2)
        Write(n);
        
    WriteLine("");
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
void FindPrimeFactors(int n) 
{
    SplashKit.WriteLine($"Prime factors of {n}:");
    
    // Extract all factors of 2
    while (n % 2 == 0) 
    {
        SplashKit.Write("2 ");
        n /= 2;
    }
    
    // Check odd numbers up to square root
    for (int i = 3; i * i <= n; i += 2) 
    {
        while (n % i == 0) 
        {
            SplashKit.Write($"{i} ");
            n /= i;
        }
    }
    
    // If n is still greater than 2, it's a prime factor
    if (n > 2)
        SplashKit.Write(n.ToString());
        
    SplashKit.WriteLine("");
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def find_prime_factors(n):
    write_line(f"Prime factors of {n}:")
    
    # Extract all factors of 2
    while n % 2 == 0:
        write("2 ")
        n //= 2
    
    # Check odd numbers up to square root
    for i in range(3, int(n**0.5) + 1, 2):
        while n % i == 0:
            write(f"{i} ")
            n //= i
    
    # If n is still greater than 2, it's a prime factor
    if n > 2:
        write(str(n))
        
    write_line("")
```

</TabItem>
</Tabs>

### Checking Congruence

Two numbers $a$ and $b$ are considered congruent modulo $m$ if they yield the same remainder when divided by $m$. This relationship is written mathematically as:

$$
a \equiv b \pmod{m}
$$

For example, $38 \equiv 14 \pmod{12}$ because both numbers leave a remainder of 2 when divided by 12.

We can implement a function to check if two numbers are congruent modulo $m$ as follows:

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
bool is_congruent(int a, int b, int mod) {
    return (a % mod) == (b % mod);
}
```

</TabItem>
<TabItem label="C#">

```csharp
bool IsCongruent(int a, int b, int mod) {
    return (a % mod) == (b % mod);
}
```

</TabItem>
<TabItem label="Python">

```python
def is_congruent(a, b, mod):
    return (a % mod) == (b % mod)
```

</TabItem>
</Tabs>

## Modular Arithmetic Operations

Modular arithmetic is a system of arithmetic for integers, where numbers "wrap around" upon reaching a certain value—the modulus. This section includes functions for modular addition, subtraction, multiplication, and exponentiation. The function `modular_exponentiation` performs modular exponentiation, which raises a base to an exponent under a modulus efficiently. This operation is commonly used in cryptography and number theory.

### Modular Addition

Modular addition is the operation of adding two numbers and taking the remainder when divided by a modulus.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int modular_addition(int a, int b, int mod) {
    return (a + b) % mod;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int ModularAddition(int a, int b, int mod) {
    return (a + b) % mod;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int ModularAddition(int a, int b, int mod) {
    return (a + b) % mod;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def modular_addition(a, b, mod):
    return (a + b) % mod
```

</TabItem>
</Tabs>

### Modular Subtraction

Modular subtraction is the operation of subtracting two numbers and taking the remainder when divided by a modulus.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int modular_subtraction(int a, int b, int mod) {
    return (a - b + mod) % mod;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int ModularSubtraction(int a, int b, int mod) {
    return (a - b + mod) % mod;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int ModularSubtraction(int a, int b, int mod) {
    return (a - b + mod) % mod;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def modular_subtraction(a, b, mod):
    return (a - b + mod) % mod
```

</TabItem>
</Tabs>

### Modular Multiplication

Modular multiplication is the operation of multiplying two numbers and taking the remainder when divided by a modulus.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int modular_multiplication(int a, int b, int mod) {
    return (a * b) % mod;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int ModularMultiplication(int a, int b, int mod) {
    return (a * b) % mod;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int ModularMultiplication(int a, int b, int mod) {
    return (a * b) % mod;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def modular_multiplication(a, b, mod):
    return (a * b) % mod
```

</TabItem>
</Tabs>

### Modular Exponentiation

Modular exponentiation is the operation of raising a base to an exponent under a modulus. This operation is used to calculate large powers efficiently.

<Tabs syncKey="code-language">
<TabItem label="C++">

```cpp
int modular_exponentiation(int base, int exponent, int mod) {
    int result = 1;
    base = base % mod;

    while (exponent > 0) {
        if (exponent % 2 == 1) {
            result = (result * base) % mod;
        }
        exponent >>= 1;
        base = (base * base) % mod;
    }
    return result;
}
```

</TabItem>
<TabItem label="C#">

<Tabs syncKey="csharp-style">
<TabItem label="Top-level Statements">

```csharp
int ModularExponentiation(int base, int exponent, int mod) {
    int result = 1;
    base = base % mod;

    while (exponent > 0) {
        if (exponent % 2 == 1) {
            result = (result * base) % mod;
        }
        exponent >>= 1;
        base = (base * base) % mod;
    }
    return result;
}
```

</TabItem>
<TabItem label="Object-Oriented">

```csharp
int ModularExponentiation(int base, int exponent, int mod) {
    int result = 1;
    base = base % mod;

    while (exponent > 0) {
        if (exponent % 2 == 1) {
            result = (result * base) % mod;
        }
        exponent >>= 1;
        base = (base * base) % mod;
    }
    return result;
}
```

</TabItem>
</Tabs>

</TabItem>
<TabItem label="Python">

```python
def modular_exponentiation(base, exponent, mod):
    result = 1
    base = base % mod

    while exponent > 0:
        if exponent % 2 == 1:
            result = (result * base) % mod
        exponent >>= 1
        base = (base * base) % mod
    return result
```

</TabItem>
</Tabs>
